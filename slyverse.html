<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="SLYVERSE v1 ‚Äî WebXR Snake Grid by 0rb1t4lsn4k3r. Real-time multiplayer chaos with SVG NFT export and cyberpunk soul.">
  <meta name="theme-color" content="#0f0">
  <title>SLYVERSE v1 ‚Äî 0rb1t4lsn4k3r</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><path d='M50 10 Q70 30 90 50 Q70 70 50 90 Q30 70 10 50 Q30 30 50 10' fill='none' stroke='%230f0' stroke-width='4'/></svg>">
  <link rel="manifest" href="data:application/manifest+json,{'name':'SLYVERSE','short_name':'SLYVERSE','start_url':'.','display':'standalone','background_color':'#000','theme_color':'#0f0','icons':[{'src':'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Cpath d=%22M50 10 Q70 30 90 50 Q70 70 50 90 Q30 70 10 50 Q30 30 50 10%22 fill=%22none%22 stroke=%22%230f0%22 stroke-width=%224%22/%3E%3C/svg%3E','sizes':'192x192','type':'image/svg+xml'}]}">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.168.0/three.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore-compat.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-auth-compat.min.js"></script>
  <style>
    :root { --void: #000; --glitch: #0f0; --serpent: #f00; --memory: #0ff; --eclipse: #300; --pulse: 1.5s; --glitch-speed: 0.3s; --bleed: 2.7s; }
    * { margin:0; padding:0; box-sizing:border-box; }
    body { background:var(--void); color:var(--glitch); font-family:"Courier New",monospace; min-height:100vh; display:flex; flex-direction:column; align-items:center; justify-content:center; image-rendering:pixelated; overflow:hidden; }
    canvas { border:2px solid #f0f; background:#111; max-width:100%; max-height:100%; display:block; filter:contrast(1.6) brightness(1.2); }
    #ui { position:absolute; top:4px; left:4px; font-size:14px; text-shadow:0 0 6px var(--glitch); z-index:999; animation:glitch 3s infinite; }
    @keyframes glitch { 0%,100% { text-shadow:0 0 6px var(--glitch), 0 0 12px var(--glitch); } 50% { text-shadow:-2px 0 #f00, 2px 0 #0ff; } }
    #journal { position:absolute; top:4px; right:4px; width:320px; background:rgba(0,0,0,.92); padding:12px; border:1px solid var(--glitch); max-height:calc(100vh - 80px); overflow-y:auto; font-size:11px; line-height:1.3; backdrop-filter:blur(2px); }
    #journal h3 { margin:3px 0; color:var(--memory); font-style:italic; animation:glitch 2.5s infinite; }
    #journal p { margin:2px 0; color:#0a0; opacity:0; transform:translateX(-10px); transition:all .4s; }
    #journal p.show { opacity:1; transform:translateX(0); }
    #chat-input { position:absolute; bottom:4px; right:4px; width:300px; background:rgba(0,0,0,.8); color:var(--glitch); border:1px solid var(--glitch); padding:6px; font-family:monospace; z-index:1000; }
    #controls { position:absolute; bottom:4px; left:50%; transform:translateX(-50%); font-size:10px; color:#666; text-align:center; }
    #export { position:absolute; bottom:4px; left:4px; background:transparent; color:var(--glitch); border:1px dashed var(--glitch); padding:6px 12px; font-family:monospace; cursor:pointer; animation:pulse var(--pulse) infinite; }
    @keyframes pulse { 0%,100% { border-color:var(--glitch); } 50% { border-color:var(--serpent); } }
    .eclipse-overlay { position:absolute; inset:0; background:radial-gradient(circle at center, transparent 25%, var(--eclipse) 75%); pointer-events:none; opacity:0; transition:opacity 1.8s; mix-blend-mode:screen; }
    .eclipse-overlay.active { opacity:1; }
    .trail { position:absolute; width:4px; height:4px; background:radial-gradient(#0f0, transparent); border-radius:50%; pointer-events:none; opacity:0; animation:fade 0.8s forwards; }
    @keyframes fade { to { opacity:0; transform:scale(0); } }
    .soul-hash { position:absolute; bottom:16px; left:50%; transform:translateX(-50%); font-size:8px; color:#444; opacity:0; transition:opacity 1s; }
    .soul-hash.show { opacity:1; }
    .power-up { position:absolute; font-size:12px; color:#ff0; text-shadow:0 0 6px #ff0; animation:blink 0.8s infinite; }
    @keyframes blink { 0%,50% { opacity:1; } 51%,100% { opacity:0; } }
    .memory-echo { position:absolute; pointer-events:none; font-size:12px; color:var(--memory); text-shadow:0 0 8px var(--memory); animation:bleed var(--bleed) infinite, glitch 1s infinite; opacity:0; }
    @keyframes bleed { 0%,100% { filter:hue-rotate(0deg) brightness(1); } 50% { filter:hue-rotate(270deg) brightness(1.8); } }
    #alias-prompt { position:fixed; inset:0; background:rgba(0,0,0,0.95); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:1000; color:var(--glitch); }
    #alias-prompt input { background:transparent; border:1px solid var(--glitch); color:var(--glitch); padding:12px; margin:12px; font-family:monospace; font-size:16px; width:200px; }
    #alias-prompt button { background:#222; color:var(--glitch); border:1px solid var(--glitch); padding:8px 16px; font-family:monospace; cursor:pointer; }
    #leaderboard { position:absolute; top:50px; left:4px; font-size:14px; max-width:300px; background:rgba(0,0,0,.92); padding:12px; border:1px solid var(--glitch); }
    .modal { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,.95); border:2px solid var(--glitch); padding:20px; color:var(--glitch); font-size:14px; max-width:400px; text-align:center; z-index:1001; animation:fadeIn 0.5s; }
    .modal button { background:#222; color:var(--glitch); border:1px solid var(--glitch); padding:8px 16px; margin-top:10px; font-family:monospace; cursor:pointer; }
    @keyframes fadeIn { from { opacity:0; transform:translate(-50%,-60%); } to { opacity:1; transform:translate(-50%,-50%); } }
    @media (max-width:600px) {
      canvas { width:300px; height:300px; }
      #journal { width:180px; font-size:10px; }
      #chat-input { width:180px; bottom:60px; }
      #ui, #leaderboard { font-size:12px; }
      #controls { font-size:8px; }
    }
  </style>
</head>
<body>
  <div id="alias-prompt">
    <h2>SLYVERSE v1 ‚Äî Enter Alias (1-20 chars)</h2>
    <input type="text" id="alias" maxlength="20" pattern="[a-zA-Z0-9_]+" placeholder="e.g. SnakeMaster">
    <button onclick="startGame()">Join Entropy</button>
  </div>
  <canvas id="game"></canvas>
  <div id="ui">
    <span id="score">Score: 0</span> | 
    <span id="fragments">F: 0/9</span> | 
    <span id="cycle">C: 1</span> | 
    <span id="player"></span> | 
    <span id="mode">Mode: CLASSIC</span>
  </div>
  <div id="journal">
    <h3>// ENTROPY CHAT //</h3>
    <div id="chat-messages"></div>
  </div>
  <div id="leaderboard">
    <h3>üèÜ Leaderboard</h3>
    <ol id="scores"></ol>
  </div>
  <div id="controls">
    WASD/Arrows/Swipe: Move | [1]: Teleport (3F) | [2]: Cloak | [SPACE]: Start | [M]: Mode
  </div>
  <input type="text" id="chat-input" placeholder="Type message..." onkeypress="if(event.key==='Enter') sendChat()">
  <button id="export" onclick="exportSoul()">Export Soul</button>
  <div class="eclipse-overlay" id="eclipse"></div>
  <div class="soul-hash" id="soulHash"></div>

  <script>
    // Firebase Config (replace with your own)
    const firebaseConfig = {
      apiKey: "your-api-key",
      authDomain: "your-project.firebaseapp.com",
      projectId: "your-project",
      storageBucket: "your-project.appspot.com",
      messagingSenderId: "your-sender-id",
      appId: "your-app-id"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();

    // WebGL Setup
    const canvas = document.getElementById('game');
    const gl = canvas.getContext('webgl');
    canvas.width = window.innerWidth > 600 ? 600 : 300;
    canvas.height = canvas.width;
    const size = canvas.width / 30;
    let scene, camera, renderer, snakeMesh, foodMesh, powerUpMeshes = [], portalAMesh, portalBMesh;

    function initWebGL() {
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera(-15, 15, 15, -15, 0.1, 100);
      camera.position.z = 10;
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.width, canvas.height);

      // Grid Texture
      const gridCanvas = document.createElement('canvas');
      gridCanvas.width = gridCanvas.height = 512;
      const gridCtx = gridCanvas.getContext('2d');
      gridCtx.fillStyle = '#111';
      gridCtx.fillRect(0, 0, 512, 512);
      gridCtx.strokeStyle = '#222';
      gridCtx.lineWidth = 1;
      for (let i = 0; i < 30; i++) {
        gridCtx.beginPath();
        gridCtx.moveTo(i * 512/30, 0); gridCtx.lineTo(i * 512/30, 512);
        gridCtx.moveTo(0, i * 512/30); gridCtx.lineTo(512, i * 512/30);
        gridCtx.stroke();
      }
      const gridTexture = new THREE.CanvasTexture(gridCanvas);
      const gridMaterial = new THREE.MeshBasicMaterial({ map: gridTexture });
      const gridGeometry = new THREE.PlaneGeometry(30, 30);
      const gridMesh = new THREE.Mesh(gridGeometry, gridMaterial);
      scene.add(gridMesh);
    }

    // Shader for Snake
    const snakeVertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const snakeFragmentShader = `
      uniform float time;
      varying vec2 vUv;
      void main() {
        vec3 color = vec3(0.0, 1.0, 0.0);
        float glitch = sin(time * 10.0 + vUv.y * 10.0) * 0.1;
        gl_FragColor = vec4(color + glitch, 1.0);
      }
    `;
    const snakeMaterial = new THREE.ShaderMaterial({
      uniforms: { time: { value: 0 } },
      vertexShader: snakeVertexShader,
      fragmentShader: snakeFragmentShader
    });

    // Game State
    const grid = 30;
    let snake, food, dx = 0, dy = 0, score = 0, mode = 'classic', interval, portalA, portalB, leaderboard = [], powerUps = [], chatInterval, serpentWorker;
    let state = {
      cycle: 1, fragments: 0, entropy: 0, eclipsePhase: 0, timeDilation: 1, serpentAwake: false,
      actionHistory: [], soulHash: '', cooldowns: { teleport: 0, cloak: 0, speed: 0, ghost: 0, invuln: 0 },
      class: '???', player: '', milestones: 0, regrets: 0, endings: new Set()
    };

    // PWA Service Worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('data:text/javascript;base64,' + btoa('self.addEventListener("fetch",e=>e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request))));self.addEventListener("install",e=>e.waitUntil(caches.open("slyverse").then(c=>c.addAll(["/"]))));'));
    }

    // Persistence
    try { leaderboard = JSON.parse(localStorage.getItem('slyverseLB') || '[]'); } catch (e) {}
    const saved = localStorage.getItem('slyverse_soul');
    if (saved) {
      const data = JSON.parse(saved);
      state.soulHash = data.soulHash;
      state.endings = new Set(data.endings);
      document.getElementById('soulHash').textContent = `SOUL: ${state.soulHash.slice(0,12)}...`;
      document.getElementById('soulHash').classList.add('show');
    }
    function saveLB() { localStorage.setItem('slyverseLB', JSON.stringify(leaderboard)); }
    function saveSoul() {
      localStorage.setItem('slyverse_soul', JSON.stringify({ soulHash: state.soulHash, endings: Array.from(state.endings) }));
    }

    // Serpent Worker (IA)
    if (window.Worker) {
      const code = `
        let mem = [], pat = new Map(), glob = {m:0,s:0};
        self.onmessage = e => {
          const a = e.data.key;
          mem.push(a); if(mem.length>100) mem.shift();
          glob[e.data.type]++;
          const p5 = mem.slice(-5).join('');
          pat.set(p5, (pat.get(p5)||0)+1);
          if(pat.get(p5)>=3 || glob.s/(glob.m+glob.s)>0.82) {
            self.postMessage({punish:true, pattern:p5});
          }
        };
      `;
      serpentWorker = new Worker(URL.createObjectURL(new Blob([code], {type:'application/javascript'})));
      serpentWorker.onmessage = e => {
        if (e.data.punish) {
          state.regrets++;
          addJournal(`<span style="color:#f00;">// GLITCH DETECTED: "${e.data.pattern}" //</span>`);
          spawnEcho(snake[0].x * size, snake[0].y * size, "GLITCH!", '#f00');
        }
      };
    }

    // Web Audio Synth
    let audioCtx, synthNode;
    function initSynth() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      synthNode = audioCtx.createOscillator();
      synthNode.type = 'sine';
      synthNode.frequency.setValueAtTime(110, audioCtx.currentTime);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      synthNode.connect(gain);
      gain.connect(audioCtx.currentTime);
      synthNode.start();
    }
    function playSynth(freq, duration) {
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(audioCtx.currentTime);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }

    // Start Game
    function startGame() {
      state.player = document.getElementById('alias').value.trim();
      if (!state.player || !/^[a-zA-Z0-9_]+$/.test(state.player) || state.player.length < 1 || state.player.length > 20) return;
      document.getElementById('alias-prompt').style.display = 'none';
      document.getElementById('player').textContent = state.player;
      initWebGL();
      initSynth();
      reset();
      loadLeaderboard();
      startChat();
      setInterval(spawnPowerUp, 10000);
      addJournal(`<i style="color:#0ff;">// SLYVERSE v1 ‚Äî FORGED BY 0rb1t4lsn4k3r //</i>`);
      requestAnimationFrame(render);
    }

    // Leaderboard
    async function loadLeaderboard() {
      try {
        const snapshot = await db.collection('scores').orderBy('score', 'desc').limit(10).get();
        leaderboard = snapshot.docs.map(doc => doc.data());
        updateLB();
      } catch (e) { updateLB(); }
    }
    async function addScore() {
      try {
        await db.collection('scores').add({
          score, player: state.player, timestamp: firebase.firestore.Timestamp.now()
        });
        loadLeaderboard();
      } catch (e) {
        leaderboard.push({ score, player: state.player, timestamp: new Date().toLocaleDateString('es-ES') });
        leaderboard.sort((a,b) => b.score - a.score).splice(10);
        saveLB();
        updateLB();
      }
    }
    function updateLB() {
      document.getElementById('scores').innerHTML = leaderboard.map(e => `<li><strong>${e.player}</strong> ${e.score} pts ‚Äì ${e.timestamp}</li>`).join('') || '<li>‚Äî</li>';
    }

    // Chat
    function startChat() {
      chatInterval = setInterval(async () => {
        try {
          const snapshot = await db.collection('chat').orderBy('time', 'desc').limit(50).get();
          chatMessages.innerHTML = snapshot.docs.reverse().map(doc => `<p><strong>${doc.data().player}:</strong> ${doc.data().msg}</p>`).join('');
        } catch (e) { }
      }, 1500);
    }
    function sendChat() {
      const msg = document.getElementById('chat-input').value.trim();
      if (msg && msg.length <= 100) {
        db.collection('chat').add({ msg, player: state.player, time: firebase.firestore.Timestamp.now() });
        document.getElementById('chat-input').value = '';
      }
    }

    // Journal
    function addJournal(html) {
      const p = document.createElement('p');
      p.innerHTML = html;
      journal.appendChild(p);
      setTimeout(() => p.classList.add('show'), 60);
      journal.scrollTop = journal.scrollHeight;
    }

    // Echoes
    const echoes = [];
    function spawnEcho(x, y, text, color = '#0ff') {
      const el = document.createElement('div');
      el.className = 'memory-echo';
      el.textContent = text;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.color = color;
      document.body.appendChild(el);
      echoes.push(el);
      setTimeout(() => el.style.opacity = 1, 80);
      setTimeout(() => { el.remove(); echoes.splice(echoes.indexOf(el), 1); }, 4000);
    }

    // Modal
    function showModal(text) {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `<p>${text}</p><button onclick="this.parentNode.remove()">Close</button>`;
      document.body.appendChild(modal);
      setTimeout(() => modal.remove(), 5000);
    }

    // Power-ups
    function spawnPowerUp() {
      const types = ['speed', 'ghost', 'multi', 'invuln'];
      const type = types[Math.floor(Math.random() * types.length)];
      const pu = { x: Math.floor(Math.random() * grid), y: Math.floor(Math.random() * grid), type };
      while (snake.some(s => s.x === pu.x && s.y === pu.y) || (food.x === pu.x && food.y === pu.y)) {
        pu.x = Math.floor(Math.random() * grid);
        pu.y = Math.floor(Math.random() * grid);
      }
      powerUps.push(pu);
      const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
      const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(pu.x - 15 + 0.5, pu.y - 15 + 0.5, 0);
      scene.add(mesh);
      powerUpMeshes.push({ mesh, pu });
      const el = document.createElement('div');
      el.className = 'power-up';
      el.textContent = type[0].toUpperCase();
      el.style.left = (pu.x * size + size / 2) + 'px';
      el.style.top = (pu.y * size + size / 2) + 'px';
      document.body.appendChild(el);
      setTimeout(() => {
        el.remove();
        scene.remove(mesh);
        powerUpMeshes = powerUpMeshes.filter(pm => pm.mesh !== mesh);
        powerUps = powerUps.filter(p => p !== pu);
      }, 8000);
    }
    function activatePowerUp(type) {
      switch (type) {
        case 'speed':
          clearInterval(interval);
          interval = setInterval(loop, 50);
          state.cooldowns.speed = 50;
          break;
        case 'ghost':
          state.class = 'GHOST';
          state.cooldowns.ghost = 50;
          break;
        case 'multi':
          spawnFood();
          break;
        case 'invuln':
          state.serpentAwake = false;
          state.cooldowns.invuln = 30;
          break;
      }
      addJournal(`// POWER-UP: ${type.toUpperCase()} ACTIVATED //`);
      playSynth(440, 0.2);
    }

    // Game
    function reset() {
      clearInterval(interval);
      interval = null;
      snake = [{ x: 15, y: 15 }];
      spawnFood();
      dx = dy = 0;
      score = 0;
      state.fragments = 0;
      state.entropy = 0;
      state.cycle = 1;
      state.eclipsePhase = 0;
      state.timeDilation = 1;
      state.serpentAwake = false;
      state.milestones = 0;
      state.regrets = 0;
      powerUps = [];
      powerUpMeshes.forEach(pm => scene.remove(pm.mesh));
      powerUpMeshes = [];
      Object.keys(state.cooldowns).forEach(k => state.cooldowns[k] = 0);
      updateScore();
      if (mode === 'portal') spawnPortals();
      updateLB();
      addJournal(`// ${state.player} JOINS ENTROPY //`);
      scene.remove(snakeMesh);
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(snake.length * 3);
      snake.forEach((s, i) => {
        positions[i * 3] = s.x - 15 + 0.5;
        positions[i * 3 + 1] = s.y - 15 + 0.5;
        positions[i * 3 + 2] = 0;
      });
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      snakeMesh = new THREE.Line(geometry, snakeMaterial);
      scene.add(snakeMesh);
      scene.remove(foodMesh);
      const foodGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
      foodMesh = new THREE.Mesh(foodGeometry, new THREE.MeshBasicMaterial({ color: 0xff00ff }));
      foodMesh.position.set(food.x - 15 + 0.5, food.y - 15 + 0.5, 0);
      scene.add(foodMesh);
    }
    function spawnFood() {
      do {
        food = { x: Math.floor(Math.random() * grid), y: Math.floor(Math.random() * grid) };
      } while (snake.some(s => s.x === food.x && s.y === food.y) || powerUps.some(p => p.x === food.x && p.y === food.y));
      if (foodMesh) {
        foodMesh.position.set(food.x - 15 + 0.5, food.y - 15 + 0.5, 0);
      }
    }
    function spawnPortals() {
      do {
        portalA = { x: Math.floor(Math.random() * grid), y: Math.floor(Math.random() * grid) };
        portalB = { x: Math.floor(Math.random() * grid), y: Math.floor(Math.random() * grid) };
      } while (portalA.x === portalB.x && portalA.y === portalB.y || snake.some(s => s.x === portalA.x && s.y === portalA.y) || snake.some(s => s.x === portalB.x && s.y === portalB.y));
      if (portalAMesh) scene.remove(portalAMesh);
      if (portalBMesh) scene.remove(portalBMesh);
      const portalGeometry = new THREE.TorusGeometry(0.4, 0.1, 16, 32);
      portalAMesh = new THREE.Mesh(portalGeometry, new THREE.MeshBasicMaterial({ color: 0x00ffff }));
      portalBMesh = new THREE.Mesh(portalGeometry, new THREE.MeshBasicMaterial({ color: 0xffff00 }));
      portalAMesh.position.set(portalA.x - 15 + 0.5, portalA.y - 15 + 0.5, 0);
      portalBMesh.position.set(portalB.x - 15 + 0.5, portalB.y - 15 + 0.5, 0);
      scene.add(portalAMesh, portalBMesh);
    }

    // Input
    const keys = {}, touch = { x: 0, y: 0 };
    document.addEventListener('keydown', e => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d',' ','1','2','m'].includes(e.key)) e.preventDefault();
      keys[e.key] = true;
      input(e.key);
    });
    document.addEventListener('keyup', e => keys[e.key] = false);
    canvas.addEventListener('touchstart', e => {
      touch.x = e.touches[0].clientX;
      touch.y = e.touches[0].clientY;
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const dx = e.touches[0].clientX - touch.x, dy = e.touches[0].clientY - touch.y;
      if (Math.abs(dx) > 20 || Math.abs(dy) > 20) {
        move(Math.sign(dx), Math.sign(dy));
        touch.x = e.touches[0].clientX;
        touch.y = e.touches[0].clientY;
      }
    }, { passive: false });
    function input(key) {
      const type = ['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','w','a','s','d'].includes(key) ? 'm' : 's';
      state.actionHistory.push({ key, type });
      if (state.actionHistory.length > 100) state.actionHistory.shift();
      if (serpentWorker) serpentWorker.postMessage({ key, type });
      if (key === ' ') {
        if (!interval) reset();
        return;
      }
      if (key === '1' && state.cooldowns.teleport === 0 && state.fragments >= 3) cast('teleport');
      if (key === '2' && state.cooldowns.cloak === 0) cast('cloak');
      if (key === 'm') {
        const modes = ['classic', 'portal', 'ai', 'chaos'];
        mode = modes[(modes.indexOf(mode) + 1) % modes.length];
        reset();
        document.getElementById('mode').textContent = `Mode: ${mode.toUpperCase()}`;
        addJournal(`// MODE: ${mode.toUpperCase()} //`);
      }
      const k = key.toLowerCase();
      const opp = { up: 'down', down: 'up', left: 'right', right: 'left' };
      const map = { w: 'up', s: 'down', a: 'left', d: 'right', arrowup: 'up', arrowdown: 'down', arrowleft: 'left', arrowright: 'right' };
      if (map[k] && opp[map[k]] !== { up: dy === -1, down: dy === 1, left: dx === -1, right: dx === 1 }[map[k]]) {
        [dx, dy] = { up: [0, -1], down: [0, 1], left: [-1, 0], right: [1, 0] }[map[k]];
        if (!interval) interval = setInterval(loop, 100 / state.timeDilation);
      }
    }
    function move(dx, dy) {
      [dx, dy] = [dx, dy];
      if (!interval) interval = setInterval(loop, 100 / state.timeDilation);
    }

    // WebXR (Basic VR Support)
    let vrSession = null;
    async function initWebXR() {
      if (navigator.xr) {
        try {
          vrSession = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['hand-tracking'] });
          renderer.xr.enabled = true;
          await renderer.xr.setSession(vrSession);
          vrSession.addEventListener('inputsourceschange', () => {
            const sources = vrSession.inputSources;
            sources.forEach(source => {
              if (source.gamepad && source.gamepad.axes.length >= 2) {
                const [x, y] = source.gamepad.axes;
                if (Math.abs(x) > 0.5) move(Math.sign(x), 0);
                if (Math.abs(y) > 0.5) move(0, Math.sign(y));
              }
            });
          });
        } catch (e) { console.log('WebXR not supported'); }
      }
    }

    // Cast
    function cast(spell) {
      switch (spell) {
        case 'teleport':
          snake[0] = { x: Math.floor(Math.random() * grid), y: Math.floor(Math.random() * grid) };
          state.fragments -= 3;
          state.cooldowns.teleport = 55;
          addJournal(`// TELEPORT: ${snake[0].x},${snake[0].y} //`);
          playSynth(880, 0.3);
          break;
        case 'cloak':
          state.class = state.class === 'CLOAKED' ? '???' : 'CLOAKED';
          state.cooldowns.cloak = 28;
          addJournal(`// CLOAK: ${state.class === 'CLOAKED' ? 'ON' : 'OFF'} //`);
          playSynth(660, 0.2);
          break;
      }
      Object.keys(state.cooldowns).forEach(k => { if (state.cooldowns[k] > 0) state.cooldowns[k]--; });
      updateSnakeMesh();
    }

    // Loop
    function loop() {
      if (dx === 0 && dy === 0) return;
      let head = { x: snake[0].x + dx, y: snake[0].y + dy };

      // Portal
      if (mode === 'portal' && portalA && portalB) {
        if (head.x === portalA.x && head.y === portalA.y) {
          head.x = portalB.x;
          head.y = portalB.y;
        } else if (head.x === portalB.x && head.y === portalB.y) {
          head.x = portalA.x;
          head.y = portalA.y;
        }
      }

      // Walls
      if (head.x < 0 || head.x >= grid || head.y < 0 || head.y >= grid) {
        if (mode !== 'portal' && mode !== 'chaos') return gameOver();
        head.x = (head.x + grid) % grid;
        head.y = (head.y + grid) % grid;
      }

      // Self
      if (state.class !== 'GHOST' && snake.some((s, i) => i > 0 && s.x === head.x && s.y === head.y)) return gameOver();

      snake.unshift(head);
      updateSnakeMesh();

      // Eat
      if (head.x === food.x && head.y === food.y) {
        score++;
        state.fragments++;
        state.entropy += 0.42 + Math.sin(Date.now() / 1000) * Math.cos(Date.now() / 1000);
        checkMilestone();
        updateScore();
        spawnFood();
        if (mode === 'portal' && Math.random() < 0.15) spawnPortals();
        if (state.fragments >= 9) awaken();
        playSynth(440, 0.2);
        if (leaderboard[0]?.score < score || leaderboard.length < 10) addScore();
      } else {
        snake.pop();
        updateSnakeMesh();
      }

      // Power-ups
      powerUps.forEach(pu => {
        if (head.x === pu.x && head.y === pu.y) {
          activatePowerUp(pu.type);
          powerUps = powerUps.filter(p => p !== pu);
          const pm = powerUpMeshes.find(pm => pm.pu === pu);
          if (pm) {
            scene.remove(pm.mesh);
            powerUpMeshes = powerUpMeshes.filter(p => p !== pm);
          }
        }
      });

      // Chaos
      if (mode === 'chaos' && Math.random() < 0.042) {
        snake.reverse();
        updateSnakeMesh();
        addJournal(`// CHAOS REVERSAL //`);
        playSynth(220, 0.3);
      }

      // Cycle
      state.eclipsePhase += 0.0009 / Math.min(4.8, state.timeDilation);
      state.timeDilation = Math.min(4.8, state.timeDilation + 0.00009);
      document.getElementById('eclipse').style.opacity = state.eclipsePhase * 0.8;
      if (state.eclipsePhase >= 1) nextCycle();
      if (Math.random() < 0.08 && state.cycle > 1) whisper();

      if (mode === 'ai') aiMove();

      // Cooldowns
      if (state.cooldowns.speed === 1) {
        clearInterval(interval);
        interval = setInterval(loop, 100);
      }
      if (state.cooldowns.ghost === 1) state.class = '???';
      Object.keys(state.cooldowns).forEach(k => { if (state.cooldowns[k] > 0) state.cooldowns[k]--; });
    }

    // AI
    function aiMove() {
      if (mode !== 'ai' || dx === 0 && dy === 0) return;
      const head = snake[0];
      const dist = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
      const safe = dir => {
        const nx = head.x + dir[0], ny = head.y + dir[1];
        return nx >= 0 && nx < grid && ny >= 0 && ny < grid && (state.class === 'GHOST' || !snake.some(s => s.x === nx && s.y === ny));
      };
      const dirs = [[0, -1], [1, 0], [0, 1], [-1, 0]].filter(safe);
      if (dirs.length === 0) return;
      const best = dirs.reduce((a, b) => dist({ x: head.x + b[0], y: head.y + b[1] }, food) < dist({ x: head.x + a[0], y: head.y + a[1] }, food) ? b : a);
      [dx, dy] = best;
    }

    // Cycle
    function nextCycle() {
      state.cycle++;
      state.eclipsePhase = 0;
      state.timeDilation = 1;
      addJournal(`// CYCLE ${state.cycle} INIT //`);
      if (state.cycle > 16) unlockEnding('ETERNAL LOOP');
      checkEndings();
    }
    function awaken() {
      state.serpentAwake = true;
      addJournal(`<span style="color:#f00;">// SERPENT AWAKENS! //</span>`);
      for (let i = 0; i < 6; i++) {
        setTimeout(() => spawnEcho(Math.random() * canvas.width, Math.random() * canvas.height, "RUN!", '#f00'), i * 200);
      }
      setTimeout(() => state.serpentAwake = false, 3000);
      playSynth(110, 0.5);
    }
    function checkEndings() {
      if (state.fragments === 9 && state.cycle <= 2) unlockEnding('DRAGON ATE TIME');
      if (state.fragments === 0 && state.cycle > 6) unlockEnding('VOID REDEMPTION');
      if (state.regrets === 0 && state.cycle > 4) unlockEnding('IA MASTER');
      if (state.fragments > 9) unlockEnding('FRAG HOARDER');
    }
    function unlockEnding(name) {
      if (!state.endings.has(name)) {
        state.endings.add(name);
        addJournal(`<span style="color:#0ff; font-size:13px;">// ENDING: ${name} //</span>`);
        showModal(`ENDING UNLOCKED: ${name}`);
        saveSoul();
      }
    }

    // Milestones
    function checkMilestone() {
      const ms = [10, 50, 100, 150, 200, 250, 300];
      if (ms.includes(score) && state.milestones < ms.length) {
        state.milestones++;
        const text = `MILESTONE ${state.milestones}: The Grid Breathes`;
        addJournal(`<span style="color:#0ff;">// ${text} //</span>`);
        showModal(text);
        spawnEcho(snake[0].x * size, snake[0].y * size, `MILESTONE ${state.milestones}`, '#0ff');
        playSynth(880, 0.3);
      }
    }

    // Export
    async function exportSoul() {
      const hist = JSON.stringify(state.actionHistory.slice(-100));
      const data = new TextEncoder().encode(hist + score + state.cycle + state.regrets);
      const hash = Array.from(new Uint8Array(await crypto.subtle.digest('SHA-256', data)))
        .map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 32);
      state.soulHash = hash;
      document.getElementById('soulHash').textContent = `SOUL: ${hash.slice(0,12)}...`;
      document.getElementById('soulHash').classList.add('show');
      addJournal(`// SOUL EXPORTED: ${hash.slice(0,12)}... //`);
      saveSoul();
      if (score >= 100) exportSVG();
      playSynth(660, 0.3);
    }
    function exportSVG() {
      let svg = `<svg viewBox="0 0 ${grid} ${grid}" xmlns="http://www.w3.org/2000/svg"><path d="`;
      snake.forEach((s, i) => {
        if (i) svg += `L${s.x} ${s.y}`;
        else svg += `M${s.x} ${s.y}`;
      });
      svg += `" stroke="#0f0" fill="none" stroke-width="${0.1 * Math.log(score)}"/></svg>`;
      const blob = new Blob([svg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${state.player}_snake_${score}.svg`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Audio
    function playBeep() {
      playSynth(440, 0.15);
    }
    function whisper() {
      const lines = [
        `KEY ${state.actionHistory.slice(-1)[0]?.key} x${state.regrets} ‚Üí PREDICTABLE?`,
        `CYCLE ${state.cycle}... WHO ARE YOU?`,
        `VOID REMEMBERS. YOU FORGET.`
      ];
      const txt = lines[Math.floor(Math.random() * lines.length)];
      addJournal(`<i style="color:#f00;">// "${txt}" //</i>`);
      playSynth(110, 0.4);
    }

    // Render
    function updateSnakeMesh() {
      const positions = new Float32Array(snake.length * 3);
      snake.forEach((s, i) => {
        positions[i * 3] = s.x - 15 + 0.5;
        positions[i * 3 + 1] = s.y - 15 + 0.5;
        positions[i * 3 + 2] = 0;
      });
      snakeMesh.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      snakeMesh.geometry.attributes.position.needsUpdate = true;
    }
    function render() {
      snakeMaterial.uniforms.time.value += 0.01;
      if (state.serpentAwake) {
        const circleGeometry = new THREE.CircleGeometry(5, 32);
        const circleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        scene.add(circle);
        setTimeout(() => scene.remove(circle), 3000);
      }
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    // Score
    function updateScore() {
      document.getElementById('score').textContent = `Score: ${score}`;
      document.getElementById('fragments').textContent = `F: ${state.fragments}/9`;
      document.getElementById('cycle').textContent = `C: ${state.cycle}`;
    }

    // Game Over
    function gameOver() {
      clearInterval(interval);
      interval = null;
      addJournal(`<span style="color:#f00;">// GAME OVER: ${score} //</span>`);
      showModal(`GAME OVER: Score ${score}<br>Press [SPACE] to Restart`);
      if (leaderboard[0]?.score < score || leaderboard.length < 10) addScore();
      playSynth(220, 0.5);
    }

    // Konami
    const konami = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65];
    let konamiIndex = 0;
    document.addEventListener('keydown', e => {
      if (e.keyCode === konami[konamiIndex]) {
        konamiIndex++;
        if (konamiIndex === konami.length) {
          state.fragments += 3;
          addJournal(`// KONAMI UNLOCKED: +3 FRAGMENTS //`);
          updateScore();
          konamiIndex = 0;
          playSynth(880, 0.3);
        }
      } else konamiIndex = 0;
    });

    // Init
    updateLB();
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth > 600 ? 600 : 300;
      canvas.height = canvas.width;
      renderer.setSize(canvas.width, canvas.height);
    });
  </script>
</body>
</html>