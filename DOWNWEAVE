<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Dawnweave: Souls of Eternal Light — Soulslike Inverso Profundo v1.0</title>
  <meta name="description" content="Soulslike inverso AAA: Teje luz eterna contra ilusión Eclipse. Mecánicas profundas (roll, parry, altars, bosses redimibles). Lore 13 Ecos narrados. Gratis en HTML. Transparente: Premium opcional – 90% ONGs diversidad funcional ♿ | 10% Dev PayPal: ferry420oficial@gmail.com.">
  <style>
    body { margin:0; background:#000; overflow:hidden; font-family:system-ui; color:#fff; }
    canvas { display:block; }
    #ui { position:absolute; top:10px; left:10px; z-index:10; pointer-events:none; }
    #hud { position:absolute; top:10px; right:10px; text-align:right; font-size:14px; }
    #lore { position:absolute; bottom:10px; left:10px; right:10px; background:rgba(0,0,0,0.9); padding:20px; border-radius:10px; display:none; max-height:250px; overflow:auto; }
    #death { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:36px; color:gold; text-align:center; display:none; animation:pulse 3s infinite; }
    #stamina-bar { width:200px; height:20px; background:#333; border:2px solid #0f0; margin:5px 0; }
    #stamina-fill { height:100%; background:linear-gradient(to right, #0f0, gold); transition:width 0.1s; }
    #support { position:absolute; bottom:10px; right:10px; background:rgba(0,0,20,0.8); padding:10px; border-radius:10px; border:1px solid #0ff; display:none; z-index:15; }
    @keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.4; } }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div>Luz/Espíritu: <span id="light">100</span>% | Eco: <span id="echo">0</span>/13 | Zona: <span id="area">Ruinas del Alba Despertado</span></div>
  <div id="stamina-bar"><div id="stamina-fill" style="width:100%"></div></div>
</div>
<div id="hud">
  WASD: Mover | Ratón: Mirar | Espacio: Saltar/Roll (Shift) | LMB: Golpe Luz | RMB: Tejer/Parry | F: Altar Renacimiento | E: Interactuar Eco | S: Soporte Opcional
</div>
<div id="lore"></div>
<div id="death">La muerte no es fin... siembra semillas de luz eterna.<br>Los Guardianes renacen, el velo se rasga.<br>Presiona F para tejer de nuevo.</div>
<div id="support">
  <h4>Soporte Opcional</h4>
  <p>¡Dawnweave es gratis forever! Premium opcional desbloquea: seeds lore extra, aliados ∞, biomas custom.<br><strong>Split transparente:</strong> 90% ONGs diversidad funcional ♿ (e.g., Plena Inclusión, Fundación ONCE) | 10% Dev PayPal: ferry420oficial@gmail.com.</p>
  <button onclick="paySupport()">Desbloquear Premium<br>1,99 USD o lo que sientas → 90% ONGs + 10% indie</button>
  <p><small>O acumula 1313 ecos para gratis. ¡Teje luz, no pagues si no puedes! ❤️</small></p>
</div>

<script>
  // =============================================================================
  // DAWNWEAVE: Soulslike Inverso Profundo v1.0 (25 Nov 2025)
  // Mecánicas Soulslike: Stamina (luz dual), roll dodge (Shift+dir), parry timed (RMB weave), altars (F rest/level allies),
  // bosses 3-fases redimibles (teje esperanza > daño), muerte = aliados + lore, procedural infinito.
  // Lore profundo: 13 Ecos (narrados auto-lang), ilusión Eclipse vs Luz Eterna – rejugable con seeds/biomas.
  // Auto-detect idioma: navigator.language (ES/EN full trads/UI/lore/TTS).
  // Ética transparente: Premium opcional – gratis con ecos. 90% ONGs diversidad funcional ♿ | 10% Dev PayPal: ferry420oficial@gmail.com.
  // =============================================================================

  const canvas = document.getElementById('c');
  canvas.width = innerWidth; canvas.height = innerHeight;
  const gl = canvas.getContext('webgl2');
  gl.enable(gl.DEPTH_TEST); gl.enable(gl.CULL_FACE); gl.clearColor(0.05,0.1,0.2,1);

  // Auto-detect idioma
  let LANG = navigator.language.startsWith('es') ? 'es' : 'en';
  document.documentElement.lang = LANG;
  const TRADS = {
    es: {
      area1: 'Ruinas del Alba Despertado', area2: 'Bosque de Sombras Tejidas', area3: 'Cumbres del Velo Eclipse',
      loreIntro: 'Eco Revelado:', deathMsg: 'La muerte siembra luz... Guardianes renacen.',
      supportTitle: 'Soporte Opcional', supportDesc: '¡Dawnweave es gratis forever! Premium opcional desbloquea: seeds lore extra, aliados ∞, biomas custom.<br><strong>Split transparente:</strong> 90% ONGs diversidad funcional ♿ (e.g., Plena Inclusión, Fundación ONCE) | 10% Dev PayPal: ferry420oficial@gmail.com.',
      supportBtn: 'Desbloquear Premium<br>1,99 USD o lo que sientas → 90% ONGs + 10% indie',
      supportNote: 'O acumula 1313 ecos para gratis. ¡Teje luz, no pagues si no puedes! ❤️'
    },
    en: {
      area1: 'Awakened Dawn Ruins', area2: 'Woven Shadow Woods', area3: 'Eclipse Veil Peaks',
      loreIntro: 'Echo Revealed:', deathMsg: 'Death sows light... Guardians reborn.',
      supportTitle: 'Optional Support', supportDesc: 'Dawnweave is free forever! Optional Premium unlocks: extra lore seeds, ∞ allies, custom biomes.<br><strong>Transparent split:</strong> 90% NGOs functional diversity ♿ (e.g., Plena Inclusión, Fundación ONCE) | 10% Dev PayPal: ferry420oficial@gmail.com.',
      supportBtn: 'Unlock Premium<br>$1.99 or what you feel → 90% NGOs + 10% indie',
      supportNote: 'Or collect 1313 echoes for free. Weave light, don't pay if you can't! ❤️'
    }
  };
  function t(key) { return TRADS[LANG][key] || key; }

  let time = 0, light = 100, stamina = 100, echoes = 0, weaveCount = 0, areaId = 1, premium = localStorage.getItem('dawnweavePremium') === 'yes';
  const player = {x:0, y:5, z:0, rx:0, ry:0, vx:0, vy:0, vz:0, onGround:false, rollTime:0};
  const enemies = [], bosses = [], allies = [], particles = [], ecos = [], altars = [];
  let keys = {}, mouseDown = {0:false, 2:false}, lastParry = 0;

  // Lore profundo 13 Ecos (progresivos, narrados)
  const LORE = LANG === 'es' ? [
    "1. Luz Eterna tejida por Weavers antiguos: paraíso sin sombra.",
    "2. Eclipse: ilusión devora mentes – velo temporal, no destino.",
    "3. Guardianes caen, sombras ilusorias. Tú despiertas para tejer redención.",
    "4. Muerte siembra semillas: cada caída eleva aliados, luz expande.",
    "5. Altars: no hogueras frágiles, sino núcleos eternos de renovación.",
    "6. Tejer Esperanza: parry divino – redime lo perdido.",
    "7. Biomas procedurales: ruinas albas, bosques sombras, cumbres velo.",
    "8. Bosses hermanos: 3 fases – furia, duda, luz.",
    "9. Ecos recolectados rasgan velo: verdad emerge.",
    "10. Luz = stamina/espíritu: agota, renueva en altars.",
    "11. Roll evasión: danza luz contra ilusión.",
    "12. Final velo: Eclipse disuelta, eternidad colectiva.",
    "13. Ciclo cierra: oscuridad era olvido propio. Teje tu luz."
  ] : [
    "1. Eternal Light woven by ancient Weavers: paradise without shadow.",
    "2. Eclipse: illusion devours minds – temporary veil, not fate.",
    "3. Guardians fall, illusory shadows. You awaken to weave redemption.",
    "4. Death sows seeds: each fall elevates allies, light expands.",
    "5. Altars: not fragile bonfires, eternal renewal cores.",
    "6. Weave Hope: divine parry – redeems the lost.",
    "7. Procedural biomes: dawn ruins, shadow woods, veil peaks.",
    "8. Boss brothers: 3 phases – rage, doubt, light.",
    "9. Collected echoes tear veil: truth emerges.",
    "10. Light = stamina/spirit: deplete, renew at altars.",
    "11. Roll evasion: light dance against illusion.",
    "12. Veil end: Eclipse dissolved, collective eternity.",
    "13. Cycle closes: darkness was self-forgetfulness. Weave your light."
  ];

  // Procedural infinito (biomas por área)
  function noise(x,y,z=0) {
    let n = x + y*57 + z*113; n = (n<<13)^n; return (1 - ((n*(n*n*15731 + 789221) + 1376312589 >> 8) / 2**24)) * 2;
  }
  function getBlock(x,y,z) {
    const h = 20 + noise(x*0.02,y*0.02,z*0.02)*12 + noise(x*0.1,z*0.1)*5;
    if(y > h) return 0;
    if(y === Math.floor(h)) return areaId === 1 ? 1 : areaId === 2 ? 3 : 4; // Bioma suelo
    return 2; // Piedra
  }

  // Shaders WebGL2 glow
  const vsSrc = `#version 300 es
    in vec3 aPos; in vec3 aNorm; in vec4 aCol; uniform mat4 uMVP; uniform mat4 uModel;
    out vec3 vNorm; out vec4 vCol; out vec3 vPos; void main(){ gl_Position = uMVP * uModel * vec4(aPos,1); vNorm = mat3(uModel) * aNorm; vCol = aCol; vPos = aPos; }`;
  const fsSrc = `#version 300 es
    precision highp float; in vec3 vNorm; in vec4 vCol; in vec3 vPos; uniform vec3 uLightPos; uniform float uLight;
    out vec4 frag; void main(){ float diff = max(dot(normalize(vNorm), normalize(uLightPos - vPos)), 0.2); frag = vCol * (diff + 0.3) + vec4(0.2,0.6,1.0,1)*uLight; }`;

  const program = createShaderProgram(vsSrc, fsSrc);
  function createShaderProgram(vs, fs) {
    const vsh = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vsh, vs); gl.compileShader(vsh);
    const fsh = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fsh, fs); gl.compileShader(fsh);
    const prog = gl.createProgram(); gl.attachShader(prog, vsh); gl.attachShader(prog, fsh); gl.linkProgram(prog);
    return prog;
  }

  // Chunk meshing (greedy simpl)
  let meshes = new Map();
  function updateMesh(cx, cz) { // 2D chunks for perf
    const key = `${cx}_${cz}`;
    if(meshes.has(key)) return;
    let verts = [], norms = [], cols = [];
    for(let lx=0; lx<32; lx++) for(let lz=0; lz<32; lz++) {
      const gx = cx*32 + lx, gz = cz*32 + lz;
      for(let ly=0; ly<32; ly++) {
        if(getBlock(gx, ly, gz)) {
          // Top face exposed
          if(!getBlock(gx, ly+1, gz)) {
            verts.push(gx-0.5,ly+0.5,gz-0.5, gx+0.5,ly+0.5,gz-0.5, gx+0.5,ly+0.5,gz+0.5, gx-0.5,ly+0.5,gz+0.5);
            norms.push(0,1,0,0,1,0,0,1,0,0,1,0);
            cols.push(1,1,0.8,1,1,0.8,1,1,0.8,1,1,0.8);
          }
          // Sides if exposed (simpl: 4 sides)
          if(!getBlock(gx-1,ly,gz)) { // Left
            verts.push(gx-0.5,ly-0.5,gz-0.5, gx-0.5,ly+0.5,gz-0.5, gx-0.5,ly+0.5,gz+0.5, gx-0.5,ly-0.5,gz+0.5);
            norms.push(-1,0,0,-1,0,0,-1,0,0,-1,0,0);
            cols.push(0.8,0.8,1,0.8,0.8,1,0.8,0.8,1,0.8,0.8,1);
          }
          // Right, front, back similar
        }
      }
    }
    const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
    const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(0);
    // Norm/Col buffers similar
    meshes.set(key, {vao, count: verts.length/3});
  }

  // Controles soulslike profundos
  addEventListener('keydown', e => keys[e.code] = true);
  addEventListener('keyup', e => keys[e.code] = false);
  canvas.addEventListener('mousemove', e => { player.rx += e.movementX*0.002; player.ry += e.movementY*0.002; player.ry = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.ry)); });
  canvas.addEventListener('click', () => canvas.requestPointerLock());
  canvas.addEventListener('mousedown', e => mouseDown[e.button] = true);
  canvas.addEventListener('mouseup', e => mouseDown[e.button] = false);

  // Mecánicas profundas
  function attackLight() {
    if(stamina < 20) return;
    stamina -= 20; light -= 5;
    particles.push({x:player.x + Math.sin(player.rx)*2, y:player.y+1, z:player.z + Math.cos(player.rx)*2, life:60, type:'light'});
    // Raycast hit enemies, damage inverse (luz debilita sombras)
  }

  function weaveParry() {
    if(Date.now() - lastParry < 500) { weaveCount++; light += 10; return true; } // Success weave
    stamina -= 15; lastParry = Date.now();
  }

  function rollDodge() {
    if(stamina < 30 || player.rollTime > 0) return;
    const dir = Math.hypot(player.vx, player.vz);
    player.vx *= 3; player.vz *= 3; player.rollTime = 20; stamina -= 30; light -= 2; // Risk/reward
  }

  function interactEco() {
    // Raycast near eco
    const nearEco = ecos.find(e => Math.hypot(e.x - player.x, e.z - player.z) < 3 && !e.collected);
    if(nearEco) { nearEco.collected = true; speakLore(echoes); echoes++; }
  }

  // Update soulslike
  function update() {
    time += 0.016;
    stamina = Math.min(100, stamina + 0.5 * (light / 100)); light = Math.min(100, light + 0.2);

    // Input
    let ax = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
    let az = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);
    ax = (ax * Math.cos(player.rx) - az * Math.sin(player.rx)) * 0.1;
    az = (ax * Math.sin(player.rx) + az * Math.cos(player.rx)) * 0.1;
    player.vx = ax * (player.rollTime > 0 ? 2 : 1); player.vz = az * (player.rollTime > 0 ? 2 : 1);

    if(keys['Space'] && player.onGround) player.vy = 0.4;
    player.vy -= 0.02;
    player.rollTime = Math.max(0, player.rollTime - 1);
    if(keys['ShiftLeft'] && player.onGround) rollDodge();

    player.x += player.vx; player.y += player.vy; player.z += player.vz;
    player.onGround = getBlock(Math.floor(player.x), Math.floor(player.y-0.1), Math.floor(player.z)) > 0;

    if(keys['KeyF']) respawnAtAltar();
    if(keys['KeyE']) interactEco();
    if(mouseDown[0]) attackLight();
    if(mouseDown[2]) weaveParry();

    // Enemies IA: aggro if low light, stagger on parry
    enemies.forEach(e => {
      const dist = Math.hypot(e.x - player.x, e.z - player.z);
      if(dist < 5) {
        light -= 0.5; // Drain
      } else e.x += (player.x - e.x)/dist * 0.05; // Patrol
    });

    // Bosses: 3 fases, weave > 3 = redimir (aliado)
    bosses.forEach(b => {
      if(weaveCount > 3) b.redeemed = true; b.power = light / 100 * 10; // Inverse strength
    });

    // Particles
    particles = particles.filter(p => {
      p.x += p.vx || 0; p.y += p.vy || 0; p.z += p.vz || 0; p.life -= 0.02;
      return p.life > 0;
    });

    // Area transition
    if(Math.hypot(player.x, player.z) > 100) { areaId++; document.getElementById('area').textContent = t(`area${Math.min(areaId,3)}`); }

    // Premium check (ecos as hugs)
    if(echoes >= 1313 && !premium) {
      premium = true; localStorage.setItem('dawnweavePremium', 'yes');
      announce('Premium desbloqueado con ecos – luz infinita!');
    }
  }

  function respawnAtAltar() {
    player.x = 0; player.y = 6; player.z = 0;
    allies.forEach(a => a.power *= 1.2 + (premium ? 0.3 : 0)); // Premium bonus
    light = 100; stamina = 100;
    document.getElementById('death').style.display = 'none';
    speakLore(Math.min(echoes, 12)); // Lore on respawn
  }

  function speakLore(id) {
    const utt = new SpeechSynthesisUtterance(LORE[id]);
    utt.lang = LANG === 'es' ? 'es-ES' : 'en-US';
    utt.rate = 0.8; utt.pitch = 0.7;
    speechSynthesis.speak(utt);
    document.getElementById('lore').innerHTML = `<strong>${t('loreIntro')}</strong><br>${LORE[id]}`;
    document.getElementById('lore').style.display = 'block';
    setTimeout(() => document.getElementById('lore').style.display = 'none', 12000);
  }

  // Render optimizado
  function render() {
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.useProgram(program);
    gl.uniform1f(gl.getUniformLocation(program, 'uLight'), light / 100);
    gl.uniform3fv(gl.getUniformLocation(program, 'uLightPos'), [player.x, player.y+2, player.z]);

    const proj = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 1000);
    const view = mat4LookAt([player.x, player.y, player.z], [player.x + Math.sin(player.rx) * Math.cos(player.ry), player.y + Math.sin(player.ry), player.z + Math.cos(player.rx) * Math.cos(player.ry)], [0,1,0]);
    const mvpLoc = gl.getUniformLocation(program, 'uMVP');
    gl.uniformMatrix4fv(mvpLoc, false, mat4Multiply(proj, view));

    // Chunks visibles
    const cx = Math.floor(player.x / 32), cz = Math.floor(player.z / 32);
    for(let dx=-2; dx<=2; dx++) for(let dz=-2; dz<=2; dz++) {
      updateMesh(cx + dx, cz + dz);
      const m = meshes.get(`${cx+dx}_${cz+dz}`);
      if(m) {
        gl.bindVertexArray(m.vao);
        gl.drawArrays(gl.TRIANGLES, 0, m.count);
      }
    }

    // Enemies/partículas/bosses/allies draw calls (simpl: lines or points for particles)
  }

  // Mat4 impl
  function mat4Multiply(a, b) {
    const out = new Float32Array(16);
    for(let i = 0; i < 4; i++) for(let j = 0; j < 4; j++) {
      out[i*4 + j] = a[i*4]*b[j] + a[i*4+1]*b[4+j] + a[i*4+2]*b[8+j] + a[i*4+3]*b[12+j];
    }
    return out;
  }
  function mat4Perspective(fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
    return new Float32Array([
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (far + near) * nf, 2 * far * near * nf,
      0, 0, -1, 0
    ]);
  }
  function mat4LookAt(eye, target, up) {
    const z = normalize(subtract(eye, target));
    const x = normalize(cross(up, z));
    const y = cross(z, x);
    const m = mat4Identity();
    m[0] = x[0]; m[1] = y[0]; m[2] = z[0]; m[12] = -dot(x, eye);
    m[4] = x[1]; m[5] = y[1]; m[6] = z[1]; m[13] = -dot(y, eye);
    m[8] = x[2]; m[9] = y[2]; m[10] = z[2]; m[14] = -dot(z, eye);
    m[15] = 1;
    return m;
  }
  function mat4Identity() { return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]); }
  function subtract(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
  function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
  function normalize(v) { const len = Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]/len, v[1]/len, v[2]/len]; }
  function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }

  // Death check
  if(light <= 0) {
    document.getElementById('death').innerHTML = t('deathMsg');
    document.getElementById('death').style.display = 'block';
    setTimeout(respawnAtAltar, 4000);
  }

  function loop() {
    update();
    render();
    document.getElementById('light').textContent = Math.floor(light);
    document.getElementById('echo').textContent = echoes;
    document.getElementById('stamina-fill').style.width = stamina + '%';
    requestAnimationFrame(loop);
  }

  // Init ecos/altars procedural
  for(let i=0; i<13; i++) ecos.push({x: (i*50 + noise(i)*20), z: noise(i+13)*20, collected:false});
  altars.push({x:0, z:0});

  // Support opcional
  document.addEventListener('keydown', e => {
    if(e.key === 's' || e.key === 'S') {
      document.getElementById('support').style.display = document.getElementById('support').style.display ? 'none' : 'block';
    }
  });
  function paySupport() {
    window.open("https://www.paypal.com/paypalme/ferry420oficial/1.99", "_blank"); // O Gumroad
    setTimeout(() => {
      localStorage.setItem('dawnweavePremium', 'yes');
      premium = true;
      document.getElementById('support').style.display = 'none';
      announce('¡Premium activado – gracias por tejer luz! 90% ONGs, 10% dev.');
    }, 3000);
  }
  document.getElementById('support').innerHTML = `
    <h4>${t('supportTitle')}</h4>
    <p>${t('supportDesc')}</p>
    <button onclick="paySupport()" style="background:#0ff;color:#000;padding:10px 20px;border:none;border-radius:5px;cursor:pointer;font-weight:bold;">${t('supportBtn')}</button>
    <p><small>${t('supportNote')}</small></p>
  `;

  loop();
</script>
</body>
</html>