<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Thuamer v1 ¬∑ Infinite Horizon</title>
  <style>
    * { margin: 0; padding: 0; }
    body, html {
      height: 100%;
      background: #000;
      color: #0f8;
      font-family: "Noto Sans Cuneiform", monospace;
      display: grid;
      place-items: center;
      overflow: hidden;
      user-select: none;
      cursor: none;
      z-index: 1;
    }
    canvas { position: fixed; inset: 0; z-index: -1; }
    #loreText {
      font-size: 2.5vw;
      text-align: center;
      line-height: 1.4;
      opacity: 0.8;
      animation: fadeIn 12s infinite;
    }
    @keyframes fadeIn {
      0%, 100% { opacity: 0.3; transform: scale(0.96); }
      50% { opacity: 1; transform: scale(1); }
    }
    .hidden { display: none; }
    .interactive { cursor: pointer; }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<pre id="loreText">íÄ≠ Thuamer v1: Infinite Horizon</pre>

<script>
// Optimizaci√≥n avanzada de rendimiento y recursos gr√°ficos
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
let time = 0;
let loreText = document.getElementById('loreText');
const runes = "·õö·ö¢·õâíÄ≠íÅïüêçüíöüê±‚öôÔ∏è".split(""); 

// Cargar im√°genes y objetos optimizados
const particles = [];
for (let i = 0; i < 300; i++) {
  particles.push({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    velocity: Math.random() * 1.5 + 0.4,
    rune: runes[Math.floor(Math.random() * runes.length)],
    opacity: 1
  });
}

// Redimensionar canvas en tiempo real
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);

// Gr√°ficos avanzados con WebGL: shaders en tiempo real
function createShaderProgram(shaderCode) {
  const gl = canvas.getContext('webgl');
  const vertexShader = gl.createShader(gl.VERTEX_SHADER);
  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(vertexShader, `
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `);
  gl.shaderSource(fragmentShader, shaderCode);
  gl.compileShader(vertexShader);
  gl.compileShader(fragmentShader);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  return program;
}

const shaderCode = `
precision mediump float;
uniform float time;
uniform vec2 resolution;

void main() {
  vec2 uv = gl_FragCoord.xy / resolution.xy;
  uv.x += sin(time * 0.1) * 0.05;
  uv.y += cos(time * 0.1) * 0.05;
  gl_FragColor = vec4(uv.x, uv.y, 0.5 + 0.5 * sin(time), 1.0);
}`;

const shaderProgram = createShaderProgram(shaderCode);

// Funci√≥n para crear la animaci√≥n de part√≠culas
function drawParticles() {
  ctx.fillStyle = 'rgba(0,0,0,0.05)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.font = 'bold 1.5vw monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#0f0';
  ctx.shadowColor = '#0f0';
  ctx.shadowBlur = 8;

  particles.forEach(p => {
    ctx.fillText(p.rune, p.x, p.y);
    p.y += p.velocity;
    if (p.y > canvas.height) {
      p.y = 0;
      p.x = Math.random() * canvas.width;
      p.rune = runes[Math.floor(Math.random() * runes.length)];
    }
  });

  ctx.shadowBlur = 0;
  ctx.restore();
  requestAnimationFrame(drawParticles);
}
drawParticles();

// IA de narrativa din√°mica: adaptaci√≥n inteligente del jugador
const loreFragments = [
  "íÄ≠ La serpiente se enrosca, pero solo t√∫ puedes deshacerla.",
  "íÄ≠ Tu aliento ha tocado la tierra, pero tu viaje est√° lejos de terminar.",
  "1310 latidos. Un solo aliento. ¬øPor qu√© eliges seguir?",
  "íÄ≠ El Oro orbita, pero t√∫ eres el que lo controla."
];

function generateDynamicLore() {
  loreText.textContent = loreFragments[Math.floor(Math.random() * loreFragments.length)];
}

// Generaci√≥n de Lore en funci√≥n de las elecciones del jugador
let userInteraction = false;
canvas.addEventListener('click', () => {
  if (!userInteraction) {
    userInteraction = true;
    loreText.textContent = "íÄ≠ Has desbloqueado el NFT del Saber. Ahora eres un verdadero Ronin.";
    loreText.classList.add('interactive');
  }
  generateDynamicLore(); // Cambia din√°micamente el lore seg√∫n la interacci√≥n
});

// Mejora de la interactividad con IA y Machine Learning (simulaci√≥n)
function aiInteraction() {
  const interactions = [
    "íÄ≠ El eco de tus pensamientos reson√≥. ¬øEscuchas?",
    "íÄ≠ La m√°quina te observa. Un susurro de saber se te escapa.",
    "íÄ≠ El futuro ya no es incierto, el tiempo ya no es lineal. ¬øQu√© har√°s?"
  ];
  setTimeout(() => {
    if (userInteraction) {
      loreText.textContent = interactions[Math.floor(Math.random() * interactions.length)];
    }
  }, 3000);
}
aiInteraction(); // Reacci√≥n din√°mica basada en las decisiones del jugador

// Simulaci√≥n de NFTs: Generaci√≥n de NFT √∫nico
function generateNFT() {
  if (userInteraction) {
    console.log("NFT generado con c√≥digo √∫nico: 0xA1B2C3D4...");
    // Integraci√≥n con blockchain (simulada)
  }
}

// Configuraci√≥n avanzada para sonido e interactividad
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const oscillator = audioContext.createOscillator();
oscillator.type = 'sine';
oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
oscillator.connect(audioContext.destination);
oscillator.start();

// Generaci√≥n din√°mica de audio reactivo basado en la interacci√≥n del jugador
function playDynamicSound() {
  if (userInteraction) {
    oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
    oscillator.start();
  }
}
playDynamicSound(); // Simula la interacci√≥n sonora de manera reactiva

</script>

</body>
</html>
